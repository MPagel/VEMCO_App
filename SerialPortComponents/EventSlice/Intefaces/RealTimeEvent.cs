using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Dynamic;
using System.ComponentModel;

namespace EventSlice.Interfaces
{
    /// <summary>
    /// Events generated by the system should be derived from this class.
    /// </summary>
    public abstract class RealTimeEvent : DynamicObject, INotifyPropertyChanged
    {
        private string message;
        /// <summary>
        /// This the core dictionary structure for the real time event class.
        /// </summary>
        protected Dictionary<string, dynamic> _thisDict;


        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="message">Human readable description of this event</param>
        /// <param name="originatingEvent">The causal event.</param>
        /// <remarks>If this event is a consequence of an earlier event, it should be constructed
        /// with a reference to originating event.  As the object is constructed, the key/value
        /// pairs in the originating event are copied into this event and made available to
        /// future consumers of the event.  In cases where key conflict, the newer
        /// value will be used.
        /// </remarks>
        public RealTimeEvent(string message, RealTimeEvent originatingEvent)
        {
            this.message = message;
            if (originatingEvent != null)
            {
                _thisDict = originatingEvent._thisDict;
            }
            else
            {
                _thisDict = new Dictionary<string, dynamic>();
            }
        }

        /// <summary>
        /// is true if there are no key/value pairs for this event
        /// </summary>
		public bool IsEmpty { get { return _thisDict.Count == 0; } }

        /// <summary>
        /// contains the keys for this event
        /// </summary>
		public IEnumerable<string> Keys { get { return _thisDict.Keys; } }

        /// <summary>
        /// contains the values for this event
        /// </summary>
		public IEnumerable<dynamic> Values { get { return _thisDict.Values; } }

        /// <summary>
        /// Allows dynamic access to the data payload.
        /// </summary>
        /// <param name="key">The key pointing to the desired value</param>
        /// <returns>dynamic value</returns>
		public dynamic this[string key] { get { return _thisDict[key]; } set { _thisDict[key] = value; NotifyPropertyChanged(key); } }

        /// <summary>
        /// Add a key/value pair.
        /// </summary>
        /// <param name="key">The key</param>
        /// <param name="value">The value</param>
		public void Add(string key, dynamic value) {
			_thisDict.Add(key, value);
			NotifyPropertyChanged(key);
		}

        /// <summary>
        /// Remove a key/value pair.
        /// </summary>
        /// <param name="key">The key to be removed with corresponding value.</param>
        /// <returns></returns>
		public bool Remove(string key) {
			return _thisDict.Remove(key);
		}

        /// <summary>
        /// Clears the data payload.
        /// </summary>
		public void RemoveAll() {
			_thisDict.Clear();
		}

        /// <summary>
        /// Try to get a member by binder name.
        /// </summary>
        /// <param name="binder">The binder</param>
        /// <param name="result">The dynamic matching the binder</param>
        /// <returns>true if member retrieval is successful</returns>
		public override bool TryGetMember(GetMemberBinder binder, out object result) {
			return _thisDict.TryGetValue(binder.Name, out result);
		}

        /// <summary>
        /// 
        /// </summary>
        /// <param name="binder"></param>
        /// <param name="value"></param>
        /// <returns></returns>
		public override bool TrySetMember(SetMemberBinder binder, object value) {
			_thisDict[binder.Name] = value;
			NotifyPropertyChanged(binder.Name);
			return true;
		}

        /// <summary>
        /// event from PropertyChanged
        /// </summary>
		public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// handler for NotifyPropertyChanged event
        /// </summary>
        /// <param name="propertyName">the name of the property changed</param>
		public void NotifyPropertyChanged(string propertyName) {
			if (PropertyChanged != null)
				PropertyChanged(this, new PropertyChangedEventArgs(propertyName));
		}  


        /// <summary>
        /// Provides human-readable access to this event.
        /// </summary>
        /// <returns>the value contained in the message parameter</returns>
        public override string ToString()
        {
            return message;
        }
    }
}
